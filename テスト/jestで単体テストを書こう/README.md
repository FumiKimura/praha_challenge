## jestで単体テストを書こう

### 課題1 jestのドキュメントを読もう
完了!

### 課題2 (実装)
課題2の[PR](https://github.com/FumiKimura/praha-challenge-templates/pull/1)は分けてあります。

### 課題3 (質問)

#### 上記の単体テストを書くためには、依存性の注入とモック化を行う必要がありました
```
そもそも、なぜ元の関数はカバレッジ100%のテストを書けなかったのでしょうか？

回答: asyncSumOfArraySometimesZeroは返却される結果が確率的に変動するので、事前に合致する答えを用意することができない。またgetFirstNameThrowIfLongは、namiApiService内のmaxNameLengthに依存し、結果を制御することができない。結果としてカバレッジ100%のテストを書くことができない。
```

```
依存性の注入とは何でしょうか？どのような問題を解決するために使われるのでしょうか？

回答: 依存している部分を外部から注入(引き渡す)こと。具体的には、内部で作るよりも、引数でオブジェクトを外から受け入れられるようにすること。

Wikipediaによると以下のようなメリットがある
1. 結合度の低下によるコンポーネント化の促進 -> 内部でオブジェクトを初期化せず外部から引き渡す
2. 単体テストの効率化 -> モックを活用するなど
3. 特定フレームワークへの依存度低下 -> 特定のデータベースに依存しない等の書き方ができる

```
参考記事: [猿でも分かる! Dependency Injection: 依存性の注入](https://qiita.com/hshimo/items/1136087e1c6e5c5b0d9f)


```
依存性の注入を実施することで、モジュール同士の結合度の強さはどのように変化したでしょうか？

回答: 依存性の注入を利用することで、モジュール間の結合度は疎結合(loosely coupled)になります。
```

#### 「getFirstNameThrowIfLong」の関数は外部からデータを取得しているようです

```
今回のような単体テストで外部サービスとの通信が発生すると、どのようなデメリットがあるでしょうか？
回答: 単体テストが外部に対して依存するため、サービスがなくなってしまう等の都度、対応が必要になってくる。
具体的には、PRを作成すると自動テストが走るが、外部サービスに問題がありテストがパスしなくなる。
また、外部に通信するための通信環境とAPIキーの管理も必要になってくる。
```

```
（任意課題）テストには「単体テスト」「統合テスト」など様々な分類や定義があります。チーム内で「何を単体テストと呼ぶのか」「何を統合テストと呼ぶのか」など用語の定義集を作ってみても面白いかもしれません
```
- 単体テスト
  - 関数レベルの挙動をテストする
- 結合テスト
  - 単体テストが完了した2つ以上のモジュールを結合し挙動をテストする
- システムテスト (総合テスト)
  - 各環境に対して全モジュールを繋げた挙動をテストする
- ユーザーテスト
  - ユーザーが、開発した機能が要件を満たしているかをテストする

#### sumOfArrayに空の配列を渡すと例外が発生します。現状、あまり好ましい挙動ではありません。

[修正完了](https://github.com/FumiKimura/praha-challenge-templates/pull/1/commits/7a39c26774f1b1ce3e269bc84aca70c5d1c50ec9)

#### 単体テストを作成する際はテスト対象の挙動が変わり得る境界値を検討する。Property Based Testingとは?

```
Property Based Testingとは？
なぜこのテストの考え方がコード品質を向上してくれる可能性があるのでしょうか？逆に採用しない方が良いケースはあるのでしょうか？

1. Property based testingの特徴?
  - テスト対象の持っている特性をテストするために、インプット(テストケース)をランダムに大量に自動生成することでテスト範囲を拡大する
  - 特定のケースでテストが失敗した場合、テストが落ちる最小ケースを特定する
  
  特性とは、一定範囲のインプットに対して対象が振る舞う挙動
  例えば、FizzBuzzでは、与えられた数字が5の倍数であればBuzzを返却するが、
  「5の倍数」が一定範囲のデータで「Buzzを返却」が挙動にあたる。

2. なぜコードの品質を向上させる？逆に採用しない方が良いケースとは?

  なぜコードの品質を向上させることができる？
  - 大量のテストケースを作るので広範囲でテストすることができ、開発者が見逃してしまいがちなエッジケースを発見しやすくなる
  - テストが通らない最小ケースを特定することで、実装ミスを特定しやすい
  - テストケースを生成する際、同じシードを使用することでテストケースが再利用可能(逆に再利用しなくても良い)
  - インプットの組み合わせが多い場合に有効活用できそう

  採用しない方が良いケースとは？
  - 大量のケースをテストするので、パフォーマンスに影響が出そう(時間がかかる)。
    - PBTを使用する範囲は明確にする必要がある。簡単なロジックには使用しないなど。
  - 特性(property)を書く(把握する)のが難しい場合。
  - 必要十分な数の特性を書いているのか。これは普通のunitテストを書いている時と同じで、カバレッジは十分なのか?は常につきまとう。

```

参考: [My Take on Property-Based Testing](https://medium.com/erlang-battleground/property-based-testing-erlang-elixir-de72ad24966b)

#### 単体テストケースを増やしても可読性、保守性、実行速度などに問題が起きないよう工夫できることを3つ考えてみましょう

