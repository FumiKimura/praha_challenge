## jestで単体テストを書こう

### 課題1 jestのドキュメントを読もう
完了!

### 課題2 (実装)
課題2の[PR](https://github.com/FumiKimura/praha-challenge-templates/pull/1)は分けてあります。

### 課題3 (質問)

#### 上記の単体テストを書くためには、依存性の注入とモック化を行う必要がありました
```
そもそも、なぜ元の関数はカバレッジ100%のテストを書けなかったのでしょうか？

回答: asyncSumOfArraySometimesZeroは返却される結果が確率的に変動するので、事前に合致する答えを用意することができない。またgetFirstNameThrowIfLongは、namiApiService内のmaxNameLengthに依存し、結果を制御することができない。結果としてカバレッジ100%のテストを書くことができない。
```

```
依存性の注入とは何でしょうか？どのような問題を解決するために使われるのでしょうか？

回答: 依存している部分を外部から注入(引き渡す)こと。具体的には、内部で作るよりも、引数でオブジェクトを外から受け入れられるようにすること。

Wikipediaによると以下のようなメリットがある
1. 結合度の低下によるコンポーネント化の促進 -> 内部でオブジェクトを初期化せず外部から引き渡す
2. 単体テストの効率化 -> モックを活用するなど
3. 特定フレームワークへの依存度低下 -> 特定のデータベースに依存しない等の書き方ができる

```
参考記事: [猿でも分かる! Dependency Injection: 依存性の注入](https://qiita.com/hshimo/items/1136087e1c6e5c5b0d9f)


```
依存性の注入を実施することで、モジュール同士の結合度の強さはどのように変化したでしょうか？

回答: 依存性の注入を利用することで、モジュール間の結合度は疎結合(loosely coupled)になります。
```

#### 「getFirstNameThrowIfLong」の関数は外部からデータを取得しているようです

```
今回のような単体テストで外部サービスとの通信が発生すると、どのようなデメリットがあるでしょうか？
回答: 単体テストが外部に対して依存するため、サービスがなくなってしまう等の都度、対応が必要になってくる。
具体的には、PRを作成すると自動テストが走るが、外部サービスに問題がありテストがパスしなくなる。
また、外部に通信するための通信環境とAPIキーの管理も必要になってくる。
```

```
（任意課題）テストには「単体テスト」「統合テスト」など様々な分類や定義があります。チーム内で「何を単体テストと呼ぶのか」「何を統合テストと呼ぶのか」など用語の定義集を作ってみても面白いかもしれません
```
- 単体テスト
  - 関数レベルの挙動をテストする
- 結合テスト
  - 単体テストが完了した2つ以上のモジュールを結合し挙動をテストする
- システムテスト (総合テスト)
  - 各環境に対して全モジュールを繋げた挙動をテストする
- ユーザーテスト
  - ユーザーが、開発した機能が要件を満たしているかをテストする

#### sumOfArrayに空の配列を渡すと例外が発生します。現状、あまり好ましい挙動ではありません。

[修正完了](https://github.com/FumiKimura/praha-challenge-templates/pull/1/commits/7a39c26774f1b1ce3e269bc84aca70c5d1c50ec9)

#### 単体テストを作成する際はテスト対象の挙動が変わり得る境界値を検討する。Property Based Testingとは?

```
Property Based Testingとは？
なぜこのテストの考え方がコード品質を向上してくれる可能性があるのでしょうか？逆に採用しない方が良いケースはあるのでしょうか？

1. Property based testingの特徴?
  - テスト対象の持っている特性をテストするために、インプット(テストケース)をランダムに大量に自動生成することでテスト範囲を拡大する
  - 特定のケースでテストが失敗した場合、テストが落ちる最小ケースを特定する
  
  特性とは、一定範囲のインプットに対して対象が振る舞う挙動
  例えば、FizzBuzzでは、与えられた数字が5の倍数であればBuzzを返却するが、
  「5の倍数」が一定範囲のデータで「Buzzを返却」が挙動にあたる。

2. なぜコードの品質を向上させる？逆に採用しない方が良いケースとは?

  なぜコードの品質を向上させることができる？
  - 大量のテストケースを作るので広範囲でテストすることができ、開発者が見逃してしまいがちなエッジケースを発見しやすくなる
  - テストが通らない最小ケースを特定することで、実装ミスを特定しやすい
  - テストケースを生成する際、同じシードを使用することでテストケースが再利用可能(逆に再利用しなくても良い)
  - インプットの組み合わせが多い場合に有効活用できそう

  採用しない方が良いケースとは？
  - 大量のケースをテストするので、パフォーマンスに影響が出そう(時間がかかる)。
    - PBTを使用する範囲は明確にする必要がある。簡単なロジックには使用しないなど。
  - 特性(property)を書く(把握する)のが難しい場合。
  - 必要十分な数の特性を書いているのか。これは普通のunitテストを書いている時と同じで、カバレッジは十分なのか?は常につきまとう。
```

参考: [My Take on Property-Based Testing](https://medium.com/erlang-battleground/property-based-testing-erlang-elixir-de72ad24966b)

#### 単体テストケースを増やしても可読性、保守性、実行速度などに問題が起きないよう工夫できることを3つ考えてみましょう

AAA (Arrange-Act-Assert)を知らなかったのでメモ
1. Arrange - オブジェクトの初期化、テスト対象に渡されるデータの準備を行う
2. Act - 設定されたパラメーターで、設定されたメソッドを呼び出す
3. Assert - テスト対象のメソッドの挙動を確認する

1. Given-When-Thenパターンを導入する
   1. Given - 操作する前の状態
   2. When - 操作
   3. Then - 操作した結果
  パターン的にはAAAと変わりませんが、プログラムの挙動に焦点を置いています。
  一定のパターンに従うことで、開発者の可読性を向上させ認知負荷を低下させます。

2. 可読性を上げる工夫
  保守性を上げる工夫にまとめました。

3. 保守性を上げる工夫
  ユニットテストの保守性を作り込むを参考にしています。

  ユニットテストの保守性を支える原則
    1. 変更に対する堅牢生に優れる -> テスト対象・テスト設計が変更されても、テストコード変更が小さく済む
    2. 可読性に優れる -> テストコードからテストの設計や意図を読み取れる
    3. 独立性に優れる -> 他のテストメソッド、テストクラスの影響を受けない、テストの実行順序の影響を受けない
    4. 自己完結している -> Setup、テスト実行、結果の検証、Teardownの一連の処理が細かい粒度で完結している
    5. 完全自動化している -> テストを実行する処理を完全に自動化できる
    6. 細粒度なテストケース -> テストメソッドが十分に細分化されている

  ユニットテストを保守性作り込みアプローチ
  ```
  ユニットテストの実装はプログラミング行為そのものである
  保守性を高めるパターンを適用し 継続的に記述改善する必要がある
  ```
  1. 実装の工夫
    1. 重複する記述は共通化する
    2. 便利なロジックは汎用化する
    3. 可読性の向上
        1. 重要なものを目立たせる
        ```
          Customer customer2("Taro", "Yamada", 15, 2, "HOGE|FUGA|HOGEHOGE");

          必要ではない値を隠し、重要なパラメータを強調する
          Customer customer2 = createCustomer("HOGE|FUGA|HOGEHOGE");
        ```
        2. 適切な名前に置き換える
        ```
          MotorStatus motorStatus(133, 232); 
          InspectionFuga inspector; 
          inspector.set(createMaintenanceInfo(motorStatus);

          重要部分をメソッドに抜き出す
          InspectionFuga inspector = createInspectionFugaDummy();
        ```
        3. 小さくする 
          1. テストメソッドを小さくする
          2. 意図を読み取りやすい名前をつける
  2. 構造設計の工夫
    ```
      ユニットテストのテストコードはAssertionのリストではない。
      テストコードも構造を持ち、それがユニットテストの保守性に影響を与えるため、構造設計の視点が必要になる
    ```
    1. 少数のAssertionでTestCaseを構成する(1条件/1テストケースなど、テスト設計の最小構成単位を反映)
    2. 各テストケースを独立・無干渉にする影響範囲を特定しやすくする
    3. 外部インターフェースはmockやスタブを使い置換可能にする
  3. 設計の工夫
    ```
    テストコードと同じく、テスト設計も上位構造を持つ保守性の障害となるテスト条件や制約、
    テスト設計の抽象構造を抽出し、下位の設計に反映させていこう
    ```
    4. テスト設計を洗練する
       1. コンパクトなテストで十分な網羅生を確保する必要がある -> テスト設計技法やテスティングリテラシー
          1. 境界値分析
          2. カバレッジ分析
          3. テスト設計の技法や考え方のレパトリーが増えれば洗練されたテストが書けるようになる
    5. トップダウンのテスト設計で保守性を作りこむ

4. パフォーマンスを上げる工夫
   1. 必要なテストケースのみをテストする(不必要なテストを削除する)
   2. テスト自体のリファクタリング
   3. テストの[並行化](https://engineering.mercari.com/blog/entry/how_to_use_t_parallel/)
   4. 一部のテストのみを走らせられるようにRunnerを使用する
   5. テスト時間を計測し、改善を加える

参考:[Unit Test Performance Optimization](https://medium.com/@dileeppandiya/unit-test-performance-optimization-7e87aaec9dae)
参考:[ユニットテストの保守性を作りこむ](http://infog.0ch.biz/download/iseri_xpjugkansai2011.pdf)
参考:[現在時刻が関わるユニットテストから、テスト容易性設計を学ぶ](https://t-wada.hatenablog.jp/entry/design-for-testability)

#### クイズ

1. 何らかの引数を受け取り何らかの値を返却する関数を3つ作成



2. jestに関するクイズも3つ作成

#### OSSライブラリのテストケースから3つ学んだことを挙げる