# ログの取り方を学ぼう

# 課題 1

## ログレベルとは何でしょうか？

ログレベルとはログの詳細度(重要度)を定義したものです。

### どのようなレベルがあるのでしょうか？

- FATAL

  - システムが致命的なエラーによって停止する必要がある

- ERROR

  - 重大なエラーが発生したが、アプリケーションが動作を続けられる

- WARN

  - 潜在的な問題や非推奨な動作を記録する

- INFO

  - アプリケーションの正常な動作に関する情報を記録する

- DEBUG
  - デバッグのための詳細情報。通常、開発環境でのみ有効にするもの

### ログレベルを指定しておくとどのようなメリットがあるのでしょうか？

1. 問題の重要度が把握できるので高いものから処理できる
2. Debug など特定の状況のみに使用することでパフォーマンスを低下させない

## アプリケーションログにはどのような情報を含めるべきでしょうか？

- ログが発生した際のタイムスタンプ
- ログレベル
- エラーメッセージなどのイベント情報
- userId, sessionId などの関連する情報

### 逆にログに含めない方が良い情報があれば、教えてください

- パスワードや ApiKey などの認証情報
- 個人情報(ユーザーの本名)
- 不必要な情報を省いて無駄なものを減らす

## どのようなタイミングでログを出力すると良いでしょうか？（例えば「正常系の処理が終了したとき」「例外が生じたとき」など）ログレベルと併せて考えてみましょう

- 正常系の処理が終了したとき

  - INFO: 処理が正常に完了したことを記録

- 処理内容やパラメータを記録

  - DEBUG/TRACE

- 例外が発生したとき

  - ERROR: 例外の詳細（スタックトレース含む）を記録

- アプリケーションが停止する場合
  - FATAL: 重大なエラーを通知する

## ログを全て人力で検査するのは大変なので、スクリプトなどで集計しやすいように、パースしやすいメッセージを作ることも大切だと言われます。どのようなログメッセージならパースしやすくなるでしょうか？

- 構造化された形式(JSON)で一貫性のある key-value を使用する
- 形式化されていないログは Grok パーサーを使って構造化された形式(JSON)に変換する

## 以下のログの種類を説明してください

### アクセスログ

サーバー受け付けたリクエスト、HTTP によるアクセス(メソッド、パラメーター)等の履歴を記録する

### アプリケーションログ

アプリケーションや、ビジネスロジックの処理に関連する履歴を記録する

### エラーログ

アプリケーション内で処理途中に発生したエラー(例外)を記録する

### （フロントエンドの）ユーザーログ

ブラウザ上のユーザー操作やフロントエンドのイベントを記録する

### データベースのクエリログ

データベースに対して実行されたクエリや操作を記録する

## ログローテーションとは何でしょうか？

容量が大きくなり過ぎたり一定時間経過したログを定期的に別の場所に移したり消したりすること

### どのようなメリット/デメリットがあるのでしょう？

- メリット

  - ログファイルの肥大化を防ぎディスク容量の肥大化を防ぐ
  - ファイルが大きくなりすぎると読み書きパフォーマンスが低下するので整理は重要になる

- デメリット
  - 設定の複雑さと管理ミスが発生するリスク
  - データ移管時に I/O パフォーマンスが低下する

### 最近では使われる頻度が減りつつありますが、どのような背景があるのでしょうか？

クラウドベースのログ収集ツールの普及により容量を気にせずにリアルタイムで容量を気にせず収集できるので、ログローテーションの必要性が減った。

## サービスが稼働するインスタンスにログファイルを保存するのは避けた方が良いプラクティスとして言及されることもあります。それは何故でしょうか？

- 各インスタンスに保存されたログを集約・管理するのは困難
- 障害でローカル保存されたログが失われる可能性がある
- ログのアクセス制御管理が難しくなる。各インスタンスのユーザーのファイル権限を管理するのは煩雑になる。
- ログがディスク容量を圧迫する。ログローテーションで対応できるが工数が必要。

## ログを取得する仕組みには大きく分けて「プル型」と「プッシュ型」がありますが、それぞれにどのようなメリットや使い所があるのでしょうか？

- プル型（Pull 型）
  - 監視サーバーが定期的にログ発生元にアクセスしログデータを収集する
  - メリット
    - 収集対象を一元管理できる
    - ログがない場合に検知する
    - 必要な時にのみログを収集するためネットワーク帯域を圧迫しない
  - デメリット
    - ログ発生元が増えると管理工数が増大
    - 監視サーバーが polling するためリアルタイム性に欠ける
- プッシュ型（Push 型）
  - ログの発生元がログを関しサーバーやログ集約システムに送信する
  - メリット
    - 発生元がリアルタイムにログを送信する
    - 新規発生元が追加されても設定変更が不要
  - デメリット
    - 発生元がダウンしているとログ未送信で気づくのが遅れる
    - ログの送信処理(IO)が掛かってしまう
- 使い所
  - プル型
    - 監視対象が固定されており数が少ない
    - 監視サーバーで側で収集タイミングを管理したい
  - プッシュ型
    - 監視対象が動的に増減し数が多い
    - リアルタイムでのログ収集・分析が求められる
    - 各ログ発生元が異なるネットワーク環境にある

# 課題 2

## この実装にはどのようなセキュリティ上の問題がありそうでしょうか？

- Input に機密情報が保存されていると、ログから漏えいするリスク
  - 対策: ログ出力前に機密情報を検知しプレースホルダーで置き換える処理をする
- 攻撃目的のコードが入っているとログ収集ツールに対して不正な動作を誘発するリスク
  - コード実行のリスクがある
  - 対策: ログ出力前に、入力データを検証し、不正な文字列やコードが含まれていないかチェック
