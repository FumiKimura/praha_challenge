# Docker で環境差分を吸収する

## 課題 1（質問）

### Docker とは何でしょうか？初めて Docker という言葉を聞いた新人エンジニアにも分かるように説明してあげてください

Docker とは、アプリケーションとその動作に必要な環境を「コンテナ」と呼ばれる単位でまとめ、どこでも同じように動作させることができる技術です。

従来アプリケーションを別の環境で動かす際には設定の違いや依存関係の問題から、動かなくなってしまう課題がありました。

しかし、Docker はアプリケーションとその必要なライブラリや設定を一つのコンテナとしてまとめ、環境の差異をなくします。

### 以下の用語を解説してください

#### イメージ

アプリケーションの実行に必要なファイル(ライブラリ)や設定をまとめたテンプレートです。

このイメージを基に実際の動作環境であるコンテナを作成する。

#### コンテナ

必要な設定や動作に必要な環境を一つのパッケージにまとめたアプリケーションを実行する環境のことです。

#### ベースイメージ

ベースイメージとは、Dockerfile 内で FROM 文を使用して指定する他のイメージの基盤となるイメージのことです。

#### Docker レジストリ

Docker イメージを保存・管理し必要に応じて配信するためのシステムです。

#### ビルドコンテキスト

`docker build`コマンドを実行する際に、Docker デーモンに送信されるファイルやディレクトリの集合のことです。

これらのファイルは、Dockerfile 内の`COPY`や`ADD`文で参照されイメージのビルド過程で使用される。

#### マルチステージビルド

Dockerfile をイメージ構築用と実行用の複数のステージに分けること。こうすることで構築ステップを並列で実行でき、尚且つプログラムを実行するために必要なものだけを含む最小イメージを作成できます。

### Dockerfile を作成して環境構築をコード化する事にはどのようなメリットがあるのでしょうか？

1. 環境構築の自動化と効率化
   1. Dockerfile から作成したイメージからアプリケーションを実行する環境を自動で構築できる
2. 開発者間で共有し開発環境を統一できる
   1. チーム全員が同じ環境を容易に構築でき、新メンバーのオンボーディングが迅速になる
3. バージョン管理ツールで Dockerfile の変更(環境構築)の変更を管理できる
4. 環境構築手順を Dockerfile に残すので、それがドキュメントとして機能する

### docker-compose はどのような場面で役立ちそうでしょうか？

複数の Docker コンテナを一括して定義・作成・実行するツールです。

例えば、複数のサービスを連携する場合、各サービスを個別に設定・起動するのには手間がかかりますが、
docker-compose ファイルを使用すればこれらのサービスは一括定義・管理できます。

### .dockerignore にはどのようなファイルやディレクトリを含めると良いでしょうか？

.dockerignore はビルド時に費用なファイルやディレクトリをビルドコンテキストから除外するための設定ファイル

- .git などのディレクトリ
- node_modules といったビルド時や開発環境構築で生成される一時ファイル群
- 開発用の設定ファイルや API キーやパスワードが記載された設定ファイル

```
.git/

node_modules/
dist/
target/
*.log

*.env
*.bak
*.tmp

.idea/
.vscode/

config/secrets.yml
```

### パッケージについて

- apt-get などを使って必要なツールを環境にインストールしようと考えた時、Dockerfile の中で以下のように記述するのは問題ありません

  ```
  RUN apt-get update && apt-get install [something]
  ```

- しかし以下のように RUN コマンドを分割して記述すると問題が生じる（想定していたバージョンがインストールされない）可能性があります

  ```
  RUN apt-get update
  RUN apt-get install [something]
  ```

何故でしょうか？
ヒント：Docker 公式の「ベストプラクティス集」に答えが書いてあるかもしれません・・・！

#### 回答

想定されたバージョンがインストールされない理由は、イメージ構築後は全てのレイヤーは Docker のキャッシュに入るからです。
Docker は`apt-get update`を同一のコマンドと判断するため、前回の処理で作られたキャッシュを再利用します。

結果としてパッケージレポジトリが最新の状態ではなくなり、`apt-get install`が古いバージョンのまま利用される可能性が出てきます。

`  RUN apt-get update && apt-get install [something]`と記述するのはキャッシュ・バスティングと呼ばれる技術です。これは Dockerfile が確実に最新バージョンをインストールするための使われます。

参考文献: [Dockerfile を書くベストプラクティス](https://docs.docker.jp/develop/develop-images/dockerfile_best-practices.html#dockerfile)

### ENV について

ENV NAME='hoge' と記載しても、RUN export NAME='hoge'と記載しても、どちらの方法でも環境変数を設定できますが、この 2 つの設定方法には大きな違いがあります。それはなんでしょうか？

#### ENV NAME='hoge'の場合

作成されたイメージ内で永続的に保存され、コンテナの実行時にも利用できる。

#### RUN ENV NAME='hoge'の場合

`RUN`命令の実行中のみ有効な環境変数。`RUN`命令の終了後には保持されない。最終的なイメージやコンテナの実行時には利用できない。
